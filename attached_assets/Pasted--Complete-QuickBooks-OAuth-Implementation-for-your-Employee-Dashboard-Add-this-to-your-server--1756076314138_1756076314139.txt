// Complete QuickBooks OAuth Implementation for your Employee Dashboard
// Add this to your server/routes.ts or server/index.ts

import express from 'express';
import session from 'express-session';
import crypto from 'crypto';
import { db } from './db'; // Your database connection
import { integrations } from '../shared/schema'; // Your schema
import { eq } from 'drizzle-orm';

const app = express();

// REQUIRED: Session middleware for OAuth security
app.use(session({
  secret: process.env.SESSION_SECRET || 'your-session-secret',
  resave: false,
  saveUninitialized: false,
  cookie: { 
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000 // 24 hours
  }
}));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Environment variables
const QBO_CLIENT_ID = process.env.QBO_CLIENT_ID;
const QBO_CLIENT_SECRET = process.env.QBO_CLIENT_SECRET;
const QBO_REDIRECT_URI = process.env.QBO_REDIRECT_URI;
const QBO_BASE_URL = process.env.QBO_BASE_URL || 'https://quickbooks.api.intuit.com/v3/company';

// ===== QUICKBOOKS OAUTH ROUTES =====

// 1. Start OAuth Flow
app.get('/api/integrations/quickbooks/connect', async (req, res) => {
  try {
    console.log('üîµ QuickBooks connect endpoint hit');
    
    // Validate environment variables
    if (!QBO_CLIENT_ID || !QBO_CLIENT_SECRET || !QBO_REDIRECT_URI) {
      console.error('‚ùå Missing QuickBooks environment variables:', {
        hasClientId: !!QBO_CLIENT_ID,
        hasClientSecret: !!QBO_CLIENT_SECRET,
        hasRedirectUri: !!QBO_REDIRECT_URI
      });
      return res.status(500).json({ 
        success: false,
        error: 'QuickBooks integration not configured. Missing environment variables.',
        details: 'Check QBO_CLIENT_ID, QBO_CLIENT_SECRET, and QBO_REDIRECT_URI'
      });
    }

    // Generate secure random state for CSRF protection
    const state = crypto.randomBytes(32).toString('hex');
    const scopes = 'com.intuit.quickbooks.accounting';
    
    // Build QuickBooks authorization URL
    const authUrl = new URL('https://appcenter.intuit.com/connect/oauth2');
    authUrl.searchParams.set('client_id', QBO_CLIENT_ID);
    authUrl.searchParams.set('scope', scopes);
    authUrl.searchParams.set('redirect_uri', QBO_REDIRECT_URI);
    authUrl.searchParams.set('response_type', 'code');
    authUrl.searchParams.set('state', state);

    // Store state in session for verification
    if (req.session) {
      req.session.qb_state = state;
      console.log('üíæ Stored OAuth state in session');
    }

    const authUrlString = authUrl.toString();
    console.log('‚úÖ Generated QuickBooks auth URL successfully');
    console.log('üîó Auth URL length:', authUrlString.length);

    // Return JSON response with authorization URL
    res.json({ 
      success: true,
      authUrl: authUrlString,
      message: 'Authorization URL generated successfully. Redirect user to this URL to start OAuth flow.',
      clientId: QBO_CLIENT_ID.substring(0, 8) + '...', // Partial for debugging
      redirectUri: QBO_REDIRECT_URI
    });

  } catch (error) {
    console.error('üí• Error in QuickBooks connect:', error);
    res.status(500).json({ 
      success: false,
      error: 'Failed to generate authorization URL',
      details: error.message 
    });
  }
});

// 2. OAuth Callback Handler
app.get('/quickbooks/callback', async (req, res) => {
  try {
    console.log('üî¥ QuickBooks callback received');
    console.log('üìã Query parameters:', {
      hasCode: !!req.query.code,
      hasRealmId: !!req.query.realmId,
      hasState: !!req.query.state,
      codeLength: req.query.code?.toString().length || 0,
      realmId: req.query.realmId,
      state: req.query.state?.toString().substring(0, 8) + '...'
    });

    const { code, realmId, state, error } = req.query;
    
    // Check for OAuth errors
    if (error) {
      console.error('‚ùå OAuth error from QuickBooks:', error);
      return res.redirect(`/settings?qb_error=${encodeURIComponent('OAuth error: ' + error)}`);
    }

    // Validate required parameters
    if (!code) {
      console.error('‚ùå Missing authorization code');
      return res.redirect('/settings?qb_error=Missing%20authorization%20code');
    }

    if (!realmId) {
      console.error('‚ùå Missing realm ID (company ID)');
      return res.redirect('/settings?qb_error=Missing%20company%20ID');
    }

    // Verify state parameter (CSRF protection)
    if (req.session?.qb_state && state !== req.session.qb_state) {
      console.error('‚ùå State parameter mismatch:', { 
        received: state, 
        expected: req.session.qb_state?.substring(0, 8) + '...'
      });
      return res.redirect('/settings?qb_error=Invalid%20state%20parameter');
    }

    console.log('üîÑ Exchanging authorization code for tokens...');

    // Exchange authorization code for OAuth tokens
    const credentials = Buffer.from(`${QBO_CLIENT_ID}:${QBO_CLIENT_SECRET}`).toString('base64');
    const tokenResponse = await fetch('https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json',
        'Authorization': `Basic ${credentials}`
      },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code: code as string,
        redirect_uri: QBO_REDIRECT_URI
      })
    });

    const tokenData = await tokenResponse.json();
    
    if (!tokenResponse.ok) {
      console.error('‚ùå Token exchange failed:', {
        status: tokenResponse.status,
        statusText: tokenResponse.statusText,
        error: tokenData
      });
      return res.redirect(`/settings?qb_error=${encodeURIComponent('Token exchange failed: ' + (tokenData.error_description || tokenData.error))}`);
    }

    console.log('‚úÖ Token exchange successful');
    console.log('üíé Token info:', {
      hasAccessToken: !!tokenData.access_token,
      hasRefreshToken: !!tokenData.refresh_token,
      expiresIn: tokenData.expires_in,
      tokenType: tokenData.token_type
    });

    // Calculate expiration time
    const expiresAt = new Date(Date.now() + tokenData.expires_in * 1000);

    console.log('üíæ Saving QuickBooks integration to database...');

    // Save tokens to database (assuming you have an integrations table)
    await db.insert(integrations).values({
      provider: 'quickbooks',
      accessToken: tokenData.access_token,
      refreshToken: tokenData.refresh_token,
      realmId: realmId as string,
      expiresAt: expiresAt,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date()
    }).onConflictDoUpdate({
      target: integrations.provider,
      set: {
        accessToken: tokenData.access_token,
        refreshToken: tokenData.refresh_token,
        realmId: realmId as string,
        expiresAt: expiresAt,
        isActive: true,
        updatedAt: new Date()
      }
    });

    // Clear OAuth state from session
    if (req.session) {
      delete req.session.qb_state;
    }

    console.log('üéâ QuickBooks integration completed successfully');
    res.redirect('/settings?qb=connected&success=QuickBooks%20connected%20successfully');
    
  } catch (error) {
    console.error('üí• QuickBooks callback error:', error);
    res.redirect(`/settings?qb_error=${encodeURIComponent('Internal server error: ' + error.message)}`);
  }
});

// 3. Manual Sync Endpoint
app.post('/api/integrations/quickbooks/sync', async (req, res) => {
  try {
    console.log('üîÑ Manual QuickBooks sync requested');
    
    // Get QuickBooks integration from database
    const integration = await db.select()
      .from(integrations)
      .where(eq(integrations.provider, 'quickbooks'))
      .limit(1);

    if (integration.length === 0) {
      return res.status(404).json({ 
        success: false,
        error: 'QuickBooks integration not found. Please connect QuickBooks first.' 
      });
    }

    const qbIntegration = integration[0];

    if (!qbIntegration.isActive) {
      return res.status(400).json({ 
        success: false,
        error: 'QuickBooks integration is inactive. Please reconnect.' 
      });
    }

    // Check if token needs refresh
    const accessToken = await ensureValidAccessToken(qbIntegration);
    
    console.log('‚úÖ Access token validated, starting sync...');

    // TODO: Implement your sync logic here
    // Example: Sync customers, products, invoices
    
    // Update last sync time
    await db.update(integrations)
      .set({ 
        lastSyncAt: new Date(),
        updatedAt: new Date()
      })
      .where(eq(integrations.id, qbIntegration.id));

    res.json({ 
      success: true, 
      message: 'QuickBooks sync completed successfully',
      timestamp: new Date().toISOString(),
      realmId: qbIntegration.realmId
    });

  } catch (error) {
    console.error('üí• QuickBooks sync error:', error);
    res.status(500).json({ 
      success: false,
      error: 'Sync failed: ' + error.message,
      details: error.stack
    });
  }
});

// 4. Integration Status Endpoint
app.get('/api/sync/status', async (req, res) => {
  try {
    // Get all integration statuses
    const allIntegrations = await db.select().from(integrations);
    
    const status = {
      quickbooks: {
        connected: false,
        lastSync: null,
        isActive: false,
        realmId: null,
        expiresAt: null
      }
    };

    const qbIntegration = allIntegrations.find(i => i.provider === 'quickbooks');
    if (qbIntegration) {
      status.quickbooks = {
        connected: true,
        lastSync: qbIntegration.lastSyncAt,
        isActive: qbIntegration.isActive,
        realmId: qbIntegration.realmId,
        expiresAt: qbIntegration.expiresAt
      };
    }

    res.json(status);
  } catch (error) {
    console.error('üí• Status check error:', error);
    res.status(500).json({ 
      success: false,
      error: 'Failed to get integration status: ' + error.message 
    });
  }
});

// 5. Debug Token Refresh Endpoint (for troubleshooting)
app.post('/api/debug/quickbooks/refresh-token', async (req, res) => {
  try {
    const { refreshToken } = req.body;
    
    if (!refreshToken) {
      return res.status(400).json({ 
        success: false,
        error: 'refreshToken required in request body' 
      });
    }

    console.log('üîß Debug: Testing token refresh...');
    console.log('üîß Refresh token length:', refreshToken.length);
    console.log('üîß Environment check:', {
      hasClientId: !!QBO_CLIENT_ID,
      hasClientSecret: !!QBO_CLIENT_SECRET,
      clientIdLength: QBO_CLIENT_ID?.length
    });

    const result = await refreshQuickBooksToken(refreshToken);
    
    if (result.success) {
      res.json({
        success: true,
        message: 'Token refresh successful',
        hasNewAccessToken: !!result.tokens?.access_token,
        hasNewRefreshToken: !!result.tokens?.refresh_token,
        expiresIn: result.tokens?.expires_in,
        refreshTokenChanged: result.tokens?.refresh_token !== refreshToken
      });
    } else {
      res.status(400).json({
        success: false,
        error: result.error
      });
    }
  } catch (error) {
    console.error('üí• Debug route error:', error);
    res.status(500).json({ 
      success: false,
      error: 'Internal server error: ' + error.message 
    });
  }
});

// ===== HELPER FUNCTIONS =====

// Token refresh function
async function refreshQuickBooksToken(storedRefreshToken: string): Promise<{
  success: boolean;
  tokens?: any;
  error?: string;
}> {
  if (!QBO_CLIENT_ID || !QBO_CLIENT_SECRET) {
    throw new Error('QuickBooks client credentials not configured');
  }

  try {
    console.log('üîÑ Refreshing QuickBooks access token...');
    
    const credentials = Buffer.from(`${QBO_CLIENT_ID}:${QBO_CLIENT_SECRET}`).toString('base64');
    const response = await fetch('https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json',
        'Authorization': `Basic ${credentials}`
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: storedRefreshToken
      })
    });

    const data = await response.json();

    if (!response.ok) {
      console.error('‚ùå Token refresh failed:', {
        status: response.status,
        error: data
      });
      
      if (response.status === 400 && data.error === 'invalid_grant') {
        return {
          success: false,
          error: 'REFRESH_TOKEN_EXPIRED'
        };
      }
      
      return {
        success: false,
        error: `Token refresh failed: ${JSON.stringify(data)}`
      };
    }

    console.log('‚úÖ Token refresh successful');
    
    return {
      success: true,
      tokens: {
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        expires_in: data.expires_in,
        expires_at: new Date(Date.now() + data.expires_in * 1000)
      }
    };
  } catch (error) {
    console.error('üí• Network error during token refresh:', error);
    return {
      success: false,
      error: 'Network error: ' + error.message
    };
  }
}

// Ensure valid access token (refresh if needed)
async function ensureValidAccessToken(integration: any): Promise<string> {
  const fiveMinutesFromNow = new Date(Date.now() + 5 * 60 * 1000);
  
  // Check if token expires in next 5 minutes
  if (new Date(integration.expiresAt) <= fiveMinutesFromNow) {
    console.log('üîÑ Access token expires soon, refreshing...');
    
    const refreshResult = await refreshQuickBooksToken(integration.refreshToken);
    
    if (!refreshResult.success) {
      if (refreshResult.error === 'REFRESH_TOKEN_EXPIRED') {
        // Mark integration as inactive
        await db.update(integrations)
          .set({ isActive: false })
          .where(eq(integrations.id, integration.id));
        throw new Error('QuickBooks refresh token expired. User needs to re-authenticate.');
      }
      throw new Error(`Token refresh failed: ${refreshResult.error}`);
    }
    
    // Update tokens in database
    await db.update(integrations)
      .set({
        accessToken: refreshResult.tokens.access_token,
        refreshToken: refreshResult.tokens.refresh_token,
        expiresAt: refreshResult.tokens.expires_at,
        updatedAt: new Date()
      })
      .where(eq(integrations.id, integration.id));
    
    console.log('‚úÖ Tokens refreshed and saved to database');
    return refreshResult.tokens.access_token;
  }
  
  return integration.accessToken;
}

// IMPORTANT: React app serving MUST come AFTER API routes
app.use(express.static(path.join(__dirname, '../client/dist')));
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../client/dist/index.html'));
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
  console.log('üîß QuickBooks OAuth endpoints:');
  console.log('   GET  /api/integrations/quickbooks/connect');
  console.log('   GET  /quickbooks/callback');
  console.log('   POST /api/integrations/quickbooks/sync');
  console.log('   GET  /api/sync/status');
  console.log('   POST /api/debug/quickbooks/refresh-token');
});

export default app;